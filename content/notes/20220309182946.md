+++
title = "🏛Clojure"
lastmod = 2022-10-26T11:41:07+09:00
tags = ["MOC", "Clojure"]
draft = false
+++

個人的なポエム of Clojure.

refs: [🏷Clojure]({{< relref "20211111225741.md" >}}) [📝Clzojureモチベ]({{< relref "20220116175232.md" >}}) [📝Clojure思想]({{< relref "20220116161735.md" >}})

-   [🖊シンプルさが前に進む力となる Clojure | Futurismo](https://futurismo.biz/archives/4649/)
-   [🎓Clojureの生産性なんかよりも仮説思考]({{< relref "20220604145116.md" >}})
-   [💭YOASOBI/群青きいて泣いた(2022/09/01)]({{< relref "2022-w35.md#cc1dd2ab-109e-4922-8910-73bad6305231" >}})
-   [💭最近Clojureで検索するとこのサイトがでてきてけっこう迷惑]({{< relref "2022-w36.md#d8dc258f-3b4d-4ee7-9d39-a4331ca33554" >}})
-   [💭Clojureを学ぶことはSICPの挫折体験を克服すること(2022/10/13)]({{< relref "2022-w41.md#fa624251-d9f8-4671-9ec0-1a296258233c" >}})


## ClojureはJavaよりもシンプルに行数が短く書けるのは本当か？ {#4d56b6}

同じ主張はScalaでもされている.

Java8 で登場した Stream API記法をつかったコードで比較しているのかは気になる.

for文やif文を多用したJava7以前の記法のコードと比較してClojureはコードが少なく書けるんですよ!といってもそこには比較が片手落ちなきがする.

Java8以降のより関数型に近い記法でJavaを書いたらどうなるのか気になる.

[🏷Java]({{< relref "20220303203801.md" >}})


## Clojureのデータと関数は分けるを深ぼる {#0d25d929-ddd2-4348-98e0-8563f2100154}

データと操作を1つのデータ構造に納めるのがクラスでありJava流. データと操作は別々に定義するのがClojure流.

操作というものも関数値(Cの関数ポインタ)と捉えれば, 構造体への参照と関数への参照を1つのデータ型にまとめたものがクラス.

しかし整理のために, 具体的にはデータとそれに対する操作は一緒にしておかないとわたしの脳が忘れるというコーディング上の課題? への解決策としては, 1つのファイルrecordを定義したらその下にそのデータ構造を操作する関数を書く.

仮にnamespaceをアプリのドメインごとに切るとすると, 1つのnamespace，1つのファイルには１つのrecordを定義することになるのかな？ そしてそのドメインに対する操作をそのファイルに書く.

この考察の派生として, 悪い書き方は recordに対するprotocolを定義するのだれども, そのprotocolがrecord専用となってしまい, そのnamespaceにbindingsしてしまうことだ.

これをやりそうになったがこれはJavaの呪いであり, OOPからFPへ慣れてないからな気がした.

protocolはドメインのnamespaceではなくて, リスト操作を想定してそのリストの定義するところに定義するべき.

-   refs:
    -   [📝Clojure Design Architecture]({{< relref "20220314120812.md" >}})


## ClojureのImmutable Dataによってprivateという概念はなくなる？ {#0e60b4}

privateやらカプセル化やらはデータがMutableな世界において以下にバグを出さないかというためのGood Practiceとして発展したので, そもそもデータがImmutableな世界ではその概念が不要か？

それでもnamespaceでprivateな関数を宣言するのはコンピュータというよりは開発やそれを開発する人の都合か？

あるチームの関数を許可なく勝手に使うなよみたいな. 昔組込み開発していたときうちのチームの開発した便利ツールを勝手にみんな使ってさらにそのツールがバグってて苦情を言われるみたいなことがあった, 迷惑.


## Clojureの関数の引数はMapだけがいい {#a30e00}

最近思うこと. シーケンシャルデータは置いとく.

関数に対する引数でたくさんいろんいろ渡すよりもMapを一つわたしたほうがいろいろ楽な気がしてきた.

2つの引数を渡そうとしてもあとあと考えたら3つわたしたくなったとき, いちいちいろいろな場所を書き直すのが面倒. Mapを一つだけわたしてあとは[📝Clojure分配束縛]({{< relref "20220116094552.md" >}})の記法で分解すれば拡張性が高い.

そしてそれよりもClojureの思想的に, あるMapに対して関数を適用して別のMapを返す, その総体がシステムであり, 関数の巨大な集合体がWebサービスというようなきれいな解釈ができる.

ということで関数の引数にMapを一つだけわたしてそれを分配束縛するパターンを積極的につかっていきたい(これが正解とはわからない).

-   ref.
    -   [関数はSeqかAssociativeを入力しSeqかAssociativeを出力する]({{< relref "20220116161735.md#0e0467d6-3858-46bf-b7da-d684907d237d" >}})
    -   [protocolの第一引数thisとは対象の抽象データの操作を指す]({{< relref "20220517114759.md#7e22e27f-d7a2-4780-a8d5-9a4887e990db" >}})


## 💡ももいろクロージャーZ {#fc8bf287-6f06-4b0c-a67a-2b0d1b9b9613}

イタイタ[🏷Clojurians]({{< relref "20220216154041.md" >}})の別名.
