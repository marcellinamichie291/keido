+++
title = "📝Clojure マクロ"
lastmod = 2022-10-19T15:11:08+09:00
tags = ["WIKI", "Clojure"]
draft = false
+++

-   up: [📂Clojure Core Languages]({{< relref "20220112142936.md" >}})
-   tags: [🔖Macro]({{< relref "20220114080415.md#7ef5163c-758c-40c7-876d-babce8d6306d" >}})
-   links
    -   [Clojure - マクロ(macro)](https://japan-clojurians.github.io/clojure-site-ja/reference/macros)


## ClojureマクロOverview {#ca624d}

Clojure マクロの仕組みは2stepにわけられる.

1.  マクロ展開
2.  コンパイル

Clojureはマクロに出会うと, マクロがまず展開され, その結果がプログラム中のマクロのあった位置に置き換えられる(マクロ展開時処理). その次に通常のコンパイルが動く(コンパイル時処理).


### macroexpand: マクロ展開 {#bd555087-a0e5-4b23-a11d-9d746f573b08}

Clojureのマクロは関数と同じように使うことができる. そのため, predefinedなmacroは実は気づかないでたくさんつかっていることがある.

フォームの先頭にクオート(')をつけて **macroexpand** を叩くと, マクロ展開されてコンパイルに評価される前のフォームが現れる.

macroexpandのサブ関数として **macroexpand-1** がある. REPL上でのデバック利用する. macroexpandはマクロが展開できる限り再帰的にmacroexpand-1を呼び出している, という関係.

---

[Emacs CIDER]({{< relref "20220316151158.md#3f666d7d-d303-41ba-911c-50f65fb31c92" >}})にはcider-macroexpand-1/cider-macroexpand-allという関数があり, フォームの末尾でこれを叩くと別バッファに展開されたフォームが表示される.

---

[ClojureのThreading Macros]({{< relref "20220116083656.md#508f51c6-37cb-4b61-9bce-91075f1f067e" >}})の中身を理解するときにmacroexpandは活用できる.


### Clojure: リーダマクロ {#29c96e8e-02b0-4883-a59e-b08b4b6a70fb}

Reader Macros.

変な記号のシンタックスで表現されてClojureヤバそうという雰囲気を醸し出すもの. コードを簡単に記述するためのルールなので, 覚えてしまえばもう友達. 種類はそこそこある.

-   refs.
    -   [📝Clojure Macros]({{< relref "20220302111024.md" >}})
-   links
    -   (en): [Clojure - The Reader](https://clojure.org/reference/reader#syntax-quote)
    -   (ja): [Clojure - リーダー(reader)](https://japan-clojurians.github.io/clojure-site-ja/reference/reader)
    -   [Clojure のリーダーマクロについて (lisp reader macro advent calendar 2012 の記事です)。 · GitHub](https://gist.github.com/ponkore/4195740)


## Clojure マクロ定義Basics {#620641}

ここではPredefinedなマクロではなくて, 自分でマクロを定義する知識をまとめる.


### defmacro: マクロ定義/マクロ評価 {#1fb09c}

マクロを定義するには, **defmacro** をつかう.

symbolの前に **quote** またはシングルクオート(')をつけるとdefmacro内で評価されない.

-   マクロ引数に対してはなにもしなくていい.
-   nilは何度評価してもnilなのでなにもつけない.


### シンタックスクオート {#9c4b1d}

リーダマクロとして **シンタックスクオート** (または構文クオート) というのがある.

-   (\`): synax-quote, \`はバッククオート(backquote)
-   (~):  unquote, ~はチルダ.
-   (~@): unquote-splicing

シンタックスクオートはクオートと同じ役割だが, シンタックスクオートとされたリストの中でチルダに出会ったときの挙動が異なる.

-   unquote(~)に出会うとそれ以後のクオートがoffになる
    -   =すなわち式として評価されて値が展開される.
-   unquote-splice(~@)に出会うとそれ以後のクオートがoffになり, さらにリストの中身が展開される.

unquote-spliceは引数として渡されたフォームを評価しようとしたらカッコが余分についているパターンがとても多いため, その改善ために~を改良して作られたもの.

ref. [Clojure - The Reader](https://clojure.org/reference/reader#syntax-quote)


## マクロ利用の指針 {#f9203b}


### マクロ利用の指針 from Programming Clojure {#11d1f8}

1.  マクロを書くな.
2.  それがパターンをカプセル化する唯一の方法ならば, マクロを書け.
3.  同等の関数に比べて, 呼び出し側が楽になるならばマクロを書いても構わない.

---

繰り返し現れる **特殊形式** (ex. if) を マクロで共通化する.

デザインパターンとは, 多態的なインスタンス化のパターンに過ぎない. 同様にして, マクロとは共通部分を括りだす層であり, プログラミング言語そのものの記法などの, 既存の文法では括りだすことが難しいところを共通部分として切り出す.

たとえば, unless記法がない言語では if !hogeのように!を多用する. しかし何度も何度も!が使われるならば, もはやその記法には独自の定義を与えたほうが読みやすいだろう, そういうことだ.

ref: [📚Programming Clojure]({{< relref "20220307081341.md" >}})


## マクロパターン {#606128}


### by Programming Clojure {#77a703}

だいたい6つのパターンに分類することができる.

ref: [📚Programming Clojure]({{< relref "20220307081341.md" >}})

ちょくちょく実例へのリンクを書き足していきたい(urlつきで).


#### 条件的な評価 {#463ade}


#### varの定義 {#1c56f5}


#### Javaの呼び出し {#8ff7c3}


#### 評価の遅延 {#dfa6b7}


#### 評価を包む {#3c37ca}


#### lambdaの省略 {#5a6996}


### 3 patterns by matthew downey {#ca2588}

ref. [Writing Three Kinds of Clojure Macros | Matthew Downey](https://matthewdowney.github.io/writing-three-kinds-of-clojure-macros.html)


## Clojure マクロInsights {#e88131}


### 💡シングルクオートとバッククオート詳説 {#937832}

シングルクオートとバッククオートの2つのシンタックスがあり, どちらもマクロのTopicsのなかで登場するので混同しがち. 自分がはじめに躓いたところなのでもう少し丁寧に.

シングルクオートはquoteのリーダマクロ. バッククオートはsyntax quoteのリーダマクロ.

synax-quoteとquoteの違いは, 引数としてはいったときにnamespaceを含むかどうか. これによりnamespaceの名前の衝突を防ぐ.

```clojure
'+
; => +

`+
; => clojure.core/+
```

また, チルダにであったときの挙動が異なる.


### 🤔applyとは non-macro版のunquote-splicing? {#a2c69b2f-1e8f-4a1c-bae6-81c616731e2c}

関数もマクロも呼びだし方は同じだが, unquote-splicingの使うシーンはapplyと似ている. どちらも[Clojure: 可変長引数関数]({{< relref "20220116094551.md#11aa1008-04ee-4554-9ebd-67470c0fc93f" >}})を受け取る時. **&** を使うケース.

[Clojure: applyとは関数適用]({{< relref "20220116094551.md#f596204e-e198-4042-a21f-608c35e86fbf" >}})であり, 無名関数とリストを受け取って関数適用する.

```clojure
(apply f '(1 2 3))
;; => (f 1 2 3)
```

これはリストのカッコを外して中身に対して関数をあてるような処理であり, unquote-splicingの動作に似ている. non-macro版がapply, macro版が~@なのかもしれない. non-macro版でのカッコを外すシンタックスはあるのかな?


## References {#d95867}

Clojureのマクロに関する日本語情報もあまり多くないのでClojure初学者赤ちゃん日本代表として情報をまとめていきたい.

-   [Clojureマクロの書き方 - Qiita](https://qiita.com/BooookStore/items/e7919d7c2504bc7a5f2b)
-   [Clojureのマクロとclojure.specのある未来 - Qiita](https://qiita.com/lagenorhynque/items/41b8ea18ccaee8a0a5db)
-   [Writing Macros | Clojure for the Brave and True](https://www.braveclojure.com/writing-macros/)
-   [Macros in Clojure - SlideShare](https://www.slideshare.net/sohta/macros-in-clojure)
